from collections import defaultdict

def anagrams(s1, s2):
  hashmap1 = defaultdict(int)
  hashmap2 = defaultdict(int)
  
  if len(s1) != len(s2):
    return False
  for i in range(len(s1)):
      hashmap1[s1[i]] += 1
      hashmap2[s2[i]] += 1
  
  return hashmap1 == hashmap2


def linked_list_find(head, target):
  current = head
  while current is not None:
    if current.val == target:
      return True
    current = current.next
  return False
      
class Node:
  def __init__(self, val):
    self.val = val
    self.next = None

def merge_lists(head_1, head_2):
  tail = None
  variable = None
  if head_1.val > head_2.val:
    tail = head_2
    current_2 = head_2.next
    current_1 = head_1
    variable = head_2
  else:
    tail = head_1
    current_1 = head_1.next
    current_2 = head_2
    variable = head_1
    
  while current_2 and current_1:
    if current_1.val > current_2.val:
      tail.next = current_2
      current_2 = current_2.next
    else:
      tail.next = current_1
      current_1 = current_1.next
    tail = tail.next
    
  if current_1:
    tail.next = current_1
  elif current_2:
    tail.next = current_2
  return variable

# class Node:
#   def __init__(self, val):
#     self.val = val
#     self.left = None
#     self.right = None
def bottom_right_value(root):
  max_depth = -1
  max_col = 0
  result = None
  def dfs(node, depth, col):
    nonlocal result
    nonlocal max_depth
    nonlocal max_col
    if result == None:
      result = node.val
    depth += 1
    if node.left or node.right:
      if node.left:
        dfs(node.left, depth, col-1)
      if node.right:
        dfs(node.right, depth, col+1)
    else:
      if depth >= max_depth:
        max_depth = depth
        result = node.val
      elif depth == max_depth and col > max_col:
        max_col = col
        result = node.val
  if root:
    dfs(root, max_depth, max_col)
  return result

class Node:
  def __init__(self, val):
    self.val = val
    self.next = None

def add_lists(head_1, head_2):
  current_1 = head_1
  current_2 = head_2
  result = None
  remainder = 0
  result_current = None
  while current_1 and current_2:
    sum = current_1.val + current_2.val + remainder
    remainder = 0
    current_1 = current_1.next
    current_2 = current_2.next
    while sum >= 10:
      sum -= 10
      remainder += 1
    new_node = Node(sum)
    if result:
      result_current.next = new_node
      result_current = result_current.next
    else:
      result = new_node
      result_current = result
  while current_1:
    sum = current_1.val + remainder
    remainder = 0
    while sum >= 10:
      sum -= 10
      remainder += 1
    new_node = Node(sum)
    result_current.next = new_node
    result_current = result_current.next
    current_1 = current_1.next
  while current_2:
    sum = current_2.val + remainder
    remainder = 0
    while sum >= 10:
      sum -= 10
      remainder += 1
    new_node = Node(sum)
    result_current.next = new_node
    result_current = result_current.next
    current_2 = current_2.next
  if remainder:
    remainder_node = Node(remainder)
    result_current.next = remainder_node
  return result


from collections import deque
def connected_components_count(graph):
  result = 0
  visited = set()

  def bfs(node):
    nonlocal result 
    nonlocal visited
    if not node in visited:
      result += 1
      queue = deque([node])
      while queue:
        current = queue.popleft()
        visited.add(current)
        for neighbor in graph[current]:
          if not neighbor in visited:
            queue.append(neighbor)

  for node in graph.keys():
    bfs(node)

  return result

from collections import deque, defaultdict

def build_graph(edges):
  graph = defaultdict(list)
  for edge in edges:
    graph[edge[0]].append(edge[1])
    graph[edge[1]].append(edge[0])

  return graph

def has_path(graph, src, dst):
  visited = set()
  queue = deque([ src ])
  while queue:
    current = queue.popleft()
    visited.add(current)
    for neighbor in graph[current]:
      if neighbor == dst:
        return True
      if not neighbor in visited:
        queue.append(neighbor)

  return False

def undirected_path(edges, node_A, node_B):
  graph = build_graph(edges)
  return has_path(graph, node_A, node_B)
from collections import deque
def has_path(graph, src, dst):
  visited = set()
  queue = deque([ src ])
  while queue:
    current = queue.popleft()
    visited.add(current)
    for neighbor in graph[current]:
      if neighbor == dst:
        return True
      if not neighbor in visited:
        queue.append(neighbor)

  return False

from collections import deque
def largest_component(graph):
  visited = set()
  largest = 0
  def bfs(node):
    nonlocal visited
    size = 0
    if not node in visited:  
      queue = deque([node])
      visited.add(node)
      while queue:
        current = queue.popleft()
        size += 1
        for neighbor in graph[current]:
          if not neighbor in visited:
            queue.append(neighbor)
            visited.add(neighbor)
    return size
  for node in graph.keys():
    resize = bfs(node)
    largest = max(largest, resize)
  return largest

# class Node:
#   def __init__(self, val):
#     self.val = val
#     self.left = None
#     self.right = None

def path_finder(root, target):
  result = []
  def dfs(node):
    nonlocal result
    if not node:
      return False
    if node.val == target:
      result.append(node.val)
      return True
    if dfs(node.left) or dfs(node.right):
      result.append(node.val)
      return True
  dfs(root)
  if result:
    return list(reversed(result))

