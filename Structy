from collections import defaultdict

def anagrams(s1, s2):
  hashmap1 = defaultdict(int)
  hashmap2 = defaultdict(int)
  
  if len(s1) != len(s2):
    return False
  for i in range(len(s1)):
      hashmap1[s1[i]] += 1
      hashmap2[s2[i]] += 1
  
  return hashmap1 == hashmap2


def linked_list_find(head, target):
  current = head
  while current is not None:
    if current.val == target:
      return True
    current = current.next
  return False
      
class Node:
  def __init__(self, val):
    self.val = val
    self.next = None

def merge_lists(head_1, head_2):
  tail = None
  variable = None
  if head_1.val > head_2.val:
    tail = head_2
    current_2 = head_2.next
    current_1 = head_1
    variable = head_2
  else:
    tail = head_1
    current_1 = head_1.next
    current_2 = head_2
    variable = head_1
    
  while current_2 and current_1:
    if current_1.val > current_2.val:
      tail.next = current_2
      current_2 = current_2.next
    else:
      tail.next = current_1
      current_1 = current_1.next
    tail = tail.next
    
  if current_1:
    tail.next = current_1
  elif current_2:
    tail.next = current_2
  return variable

# class Node:
#   def __init__(self, val):
#     self.val = val
#     self.left = None
#     self.right = None
def bottom_right_value(root):
  max_depth = -1
  max_col = 0
  result = None
  def dfs(node, depth, col):
    nonlocal result
    nonlocal max_depth
    nonlocal max_col
    if result == None:
      result = node.val
    depth += 1
    if node.left or node.right:
      if node.left:
        dfs(node.left, depth, col-1)
      if node.right:
        dfs(node.right, depth, col+1)
    else:
      if depth >= max_depth:
        max_depth = depth
        result = node.val
      elif depth == max_depth and col > max_col:
        max_col = col
        result = node.val
  if root:
    dfs(root, max_depth, max_col)
  return result
